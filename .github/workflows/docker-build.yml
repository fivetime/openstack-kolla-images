name: Build Images By Docker

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      build_target:
        description: 'What to build (leave empty for all services)'
        required: false
        default: ''
        type: string
      base_distro:
        description: 'Base distribution'
        required: false
        default: 'ubuntu'
        type: choice
        options:
          - ubuntu
          - rocky
          - debian
          - centos
      base_arch:
        description: 'Target architecture'
        required: false
        default: 'x86_64'
        type: choice
        options:
          - x86_64
          - aarch64
      release:
        description: 'Release version'
        required: false
        default: '2025.2'
        type: choice
        options:
          - '2024.2'
          - '2025.1'
          - '2025.2'
          - 'master'
      push_images:
        description: 'Push images to registry'
        required: false
        default: true
        type: boolean
      registry_type:
        description: 'Registry type'
        required: false
        default: 'ghcr'
        type: choice
        options:
          - ghcr
          - harbor
      harbor_url:
        description: 'Harbor registry URL (e.g., harbor.example.com)'
        required: false
        default: 'harbor.example.com'
        type: string
      harbor_project:
        description: 'Harbor project name (e.g., openstack)'
        required: false
        default: 'openstack'
        type: string

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Kolla
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install kolla docker

      - name: Create kolla-build.conf
        run: |
          sudo mkdir -p /etc/kolla
          RELEASE="${{ inputs.release || '2025.2' }}"
          
          # 计算分支名称
          if [ "$RELEASE" = "master" ]; then
            BRANCH="master"
          else
            BRANCH="stable/${RELEASE}"
          fi
          
          echo "OpenStack Release: $RELEASE"
          echo "Branch: $BRANCH"
          
          cat << EOF | sudo tee /etc/kolla/kolla-build.conf
          [DEFAULT]
          # 基本配置会通过命令行参数传递
          
          # 自动计算的分支变量:
          # Release: $RELEASE
          # Branch:  $BRANCH
          
          # 自定义源码仓库配置 (如需修改，在这里更改)
          
          # 示例1: 使用 git 仓库 (自定义分支)
          # [neutron-base]
          # type = git
          # location = https://github.com/yourname/neutron
          # reference = custom-branch
          
          # 示例2: 使用官方 git 仓库 (自动使用对应版本分支)
          # [neutron-base]
          # type = git
          # location = https://opendev.org/openstack/neutron
          # reference = $BRANCH
          
          # 示例3: neutron 插件 (url 类型,自动使用对应版本)
          # [neutron-server-plugin-networking-bgpvpn]
          # type = url
          # location = https://tarballs.opendev.org/openstack/networking-bgpvpn/networking-bgpvpn-$BRANCH.tar.gz
          # enabled = true
          
          # 其他服务可以在此添加自定义配置
          # [keystone-base]
          # type = git
          # location = https://github.com/yourname/keystone
          # reference = my-feature-branch
          
          # [glance-base]
          # type = git
          # location = https://gitee.com/yourname/glance
          # reference = main
          EOF
          
          echo "Generated kolla-build.conf:"
          cat /etc/kolla/kolla-build.conf

      - name: Set build variables
        id: vars
        run: |
          # 确定 Registry 和 Namespace
          REGISTRY_TYPE="${{ inputs.registry_type || 'ghcr' }}"
          
          if [ "$REGISTRY_TYPE" = "harbor" ]; then
            HARBOR_URL="${{ inputs.harbor_url }}"
            HARBOR_PROJECT="${{ inputs.harbor_project || 'openstack' }}"
          
            if [ -z "$HARBOR_URL" ]; then
              echo "Error: harbor_url is required when registry_type is harbor"
              exit 1
            fi
          
            REGISTRY="$HARBOR_URL"
            NAMESPACE="$HARBOR_PROJECT"
            echo "Using Harbor registry: $REGISTRY/$NAMESPACE"
          else
            REGISTRY="ghcr.io"
            NAMESPACE="${{ github.repository_owner }}"
            echo "Using GitHub Container Registry: $REGISTRY/$NAMESPACE"
          fi
          
          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          
          # 设置所有服务列表(分类清晰)
          CORE_SERVICES=(
            "base" "openstack-base" "keystone" "glance" "nova" "neutron" 
            "cinder" "placement" "heat" "horizon"
          )
          
          OPENSTACK_SERVICES=(
            "aodh" "barbican" "bifrost" "blazar" "ceilometer" "cloudkitty" 
            "cyborg" "designate" "gnocchi" "ironic" "ironic-inspector" "kuryr" 
            "magnum" "manila" "masakari" "mistral" "networking-baremetal" "octavia" 
            "skyline-apiserver" "skyline-console" "tacker" "trove" "venus" "watcher" "zun"
          )
          
          INFRA_SERVICES=(
            "cron" "etcd" "fluentd" "haproxy" "hacluster" "keepalived" 
            "kolla-toolbox" "letsencrypt" "mariadb" "memcached" "opensearch" 
            "openvswitch" "ovn" "ovsdpdk" "proxysql" "rabbitmq" "redis" "collectd" 
            "dnsmasq" "grafana" "influxdb" "iscsid" "multipathd" 
            "prometheus" "telegraf" "tgtd"
          )
          
          # 合并所有服务
          ALL_SERVICES=("${CORE_SERVICES[@]}" "${OPENSTACK_SERVICES[@]}" "${INFRA_SERVICES[@]}")
          
          # 确定要构建的服务
          if [ -z "${{ inputs.build_target }}" ]; then
            BUILD_SERVICES="${ALL_SERVICES[*]}"
            echo "Building all services (${#ALL_SERVICES[@]} total)"
            echo "Core: ${CORE_SERVICES[*]}"
            echo "OpenStack: ${OPENSTACK_SERVICES[*]}"
            echo "Infrastructure: ${INFRA_SERVICES[*]}"
          else
            BUILD_SERVICES="${{ inputs.build_target }}"
            echo "Building specified services: $BUILD_SERVICES"
          fi
          
          # 生成标签(官方格式:版本-系统_代号-架构)
          BASE_DISTRO="${{ inputs.base_distro || 'ubuntu' }}"
          BASE_ARCH="${{ inputs.base_arch || 'x86_64' }}"
          RELEASE="${{ inputs.release || '2025.2' }}"
          
          # 根据官方配置设置标签
          case "$BASE_DISTRO" in
            ubuntu)
              OS_TAG="ubuntu_noble"      # Ubuntu 24.04 LTS Noble Numbat
              BASE_IMAGE="ubuntu:24.04"
              ;;
            debian)
              OS_TAG="debian_bookworm"   # Debian 12 Bookworm
              BASE_IMAGE="debian:bookworm"
              ;;
            rocky)
              OS_TAG="rocky_9"           # Rocky Linux 9
              BASE_IMAGE="quay.io/rockylinux/rockylinux:9"
              ;;
            centos)
              OS_TAG="centos_stream9"    # CentOS Stream 9
              BASE_IMAGE="quay.io/centos/centos:stream9"
              ;;
            *)
              OS_TAG="ubuntu_noble"      # 默认使用 Ubuntu 24.04 Noble
              BASE_IMAGE="ubuntu:24.04"
              ;;
          esac
          
          # 架构处理
          case "$BASE_ARCH" in
            x86_64)
              ARCH_SUFFIX=""
              DEBIAN_ARCH="amd64"
              PLATFORM="linux/amd64"
              ;;
            aarch64)
              ARCH_SUFFIX="-aarch64"
              DEBIAN_ARCH="arm64"
              PLATFORM="linux/arm64"
              ;;
            *)
              ARCH_SUFFIX=""
              DEBIAN_ARCH="amd64"
              PLATFORM="linux/amd64"
              ;;
          esac
          
          # 构建完整标签
          if [ "$BASE_ARCH" = "x86_64" ]; then
            FULL_TAG="${RELEASE}-${OS_TAG}"
          else
            FULL_TAG="${RELEASE}-${OS_TAG}${ARCH_SUFFIX}"
          fi
          
          echo "build_services=$BUILD_SERVICES" >> $GITHUB_OUTPUT
          echo "full_tag=$FULL_TAG" >> $GITHUB_OUTPUT
          echo "os_tag=$OS_TAG" >> $GITHUB_OUTPUT
          echo "base_arch=$BASE_ARCH" >> $GITHUB_OUTPUT
          echo "debian_arch=$DEBIAN_ARCH" >> $GITHUB_OUTPUT
          echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
          echo "base_image=$BASE_IMAGE" >> $GITHUB_OUTPUT
          
          echo "Architecture: $BASE_ARCH (debian: $DEBIAN_ARCH, platform: $PLATFORM)"
          echo "Base image: $BASE_IMAGE"
          echo "Final tag: $FULL_TAG"

      - name: Set up Docker Buildx (for multi-arch)
        if: inputs.base_arch == 'aarch64'
        uses: docker/setup-buildx-action@v3

      - name: Build Kolla images
        run: |
          echo "Building services: ${{ steps.vars.outputs.build_services }}"
          echo "Base: ${{ inputs.base_distro || 'ubuntu' }}"
          echo "Architecture: ${{ steps.vars.outputs.base_arch }}"
          echo "OpenStack Release: ${{ inputs.release || '2025.2' }}"
          echo "Tag: ${{ steps.vars.outputs.full_tag }}"
          echo "Platform: ${{ steps.vars.outputs.platform }}"
          echo "Registry: ${{ steps.vars.outputs.registry }}"
          echo "Namespace: ${{ steps.vars.outputs.namespace }}"
          
          # 构建参数
          BUILD_ARGS=""
          if [ "${{ steps.vars.outputs.base_arch }}" = "aarch64" ]; then
            BUILD_ARGS="--platform ${{ steps.vars.outputs.platform }} --base-arch aarch64"
          fi
          
          kolla-build \
            --base ${{ inputs.base_distro || 'ubuntu' }} \
            --registry ${{ steps.vars.outputs.registry }} \
            --namespace ${{ steps.vars.outputs.namespace }} \
            --tag ${{ steps.vars.outputs.full_tag }} \
            --config-file /etc/kolla/kolla-build.conf \
            --retries 3 \
            $BUILD_ARGS \
            ${{ steps.vars.outputs.build_services }}

      - name: List built images
        if: success()
        run: |
          echo "Built images with tag: ${{ steps.vars.outputs.full_tag }}"
          docker images | grep "${{ steps.vars.outputs.registry }}/${{ steps.vars.outputs.namespace }}" | grep ${{ steps.vars.outputs.full_tag }} || echo "No images found with expected tag"
          echo ""
          echo "All images:"
          docker images | grep "${{ steps.vars.outputs.registry }}/${{ steps.vars.outputs.namespace }}" || echo "No images found"

      - name: Login to GitHub Container Registry
        if: success() && (github.event_name == 'push' || inputs.push_images == true) && inputs.registry_type != 'harbor'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CR_PAT }}

      - name: Login to Harbor Registry
        if: success() && (github.event_name == 'push' || inputs.push_images == true) && inputs.registry_type == 'harbor'
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.harbor_url }}
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}

      - name: Push images
        if: success() && (github.event_name == 'push' || inputs.push_images == true)
        run: |
          echo "Pushing images to ${{ steps.vars.outputs.registry }}/${{ steps.vars.outputs.namespace }}..."
          
          # 推送所有匹配的镜像
          for image in $(docker images --format "{{.Repository}}:{{.Tag}}" | grep "${{ steps.vars.outputs.namespace }}" | grep -v "<none>"); do
            if [[ "$image" == *"${{ steps.vars.outputs.registry }}/${{ steps.vars.outputs.namespace }}"* ]]; then
              echo "Image already has correct registry prefix: $image"
              echo "Pushing: $image"
              docker push "$image"
            else
              # 重新打标签
              new_tag="${{ steps.vars.outputs.registry }}/$image"
              echo "Retagging $image -> $new_tag"
              docker tag "$image" "$new_tag"
              echo "Pushing: $new_tag"
              docker push "$new_tag"
            fi
          done
          
          echo "Push completed!"